const pool = require('../../config/database');

module.exports = {
    deleteUser: async (id) => {
        const connection = await pool.getConnection();
        try {
            console.log(`[DELETE USER] Starting deletion for user ${id}`);
            
            // First verify user exists
            const [verifyUser] = await connection.execute(
                'SELECT id FROM users WHERE id = ?',
                [id]
            );
            
            if (verifyUser.length === 0) {
                console.log(`User ${id} not found in initial check`);
                return null;
            }
    
            await connection.beginTransaction();

            // 2. Delete user's contributions
        await connection.execute('DELETE FROM contributions WHERE user_id = ?', [id]);

        // 3. Delete user's group expenses
        await connection.execute('DELETE FROM group_expenses WHERE user_id = ?', [id]);

        // 4. Remove user from groups
        await connection.execute('DELETE FROM group_members WHERE user_id = ?', [id]);

        // 5. Delete user's group budgets
        await connection.execute('DELETE FROM group_budgets WHERE user_id = ?', [id]);

        // 6. Delete user's personal expenses
        await connection.execute('DELETE FROM expenses WHERE userId = ?', [id]);

        // 7. Delete user's personal budgets
        await connection.execute('DELETE FROM personal_budgets WHERE user_id = ?', [id]);

        // 8. Handle groups created by the user
        const [groups] = await connection.execute(
            'SELECT id FROM groups WHERE created_by = ?', 
            [id]
        );
        
        for (const group of groups) {
            await connection.execute('DELETE FROM contributions WHERE group_id = ?', [group.id]);
            await connection.execute('DELETE FROM group_expenses WHERE group_id = ?', [group.id]);
            await connection.execute('DELETE FROM group_members WHERE group_id = ?', [group.id]);
            await connection.execute('DELETE FROM group_budgets WHERE group_id = ?', [group.id]);
            await connection.execute('DELETE FROM groups WHERE id = ?', [group.id]);
        }

        // 9. Finally delete the user
        const [results] = await connection.execute(
            'DELETE FROM users WHERE id = ?',
            [id]
        );
        
        await connection.commit();
        console.log(`Successfully deleted user ${id}`);
        return results;
    } catch (error) {
        await connection.rollback();
        console.error('Transaction error:', error);
        throw error;
    } finally {
        connection.release();
    }
},


    invalidateToken: async (userId) => {
        try {
            await pool.execute(
                'UPDATE users SET token_valid = FALSE WHERE id = ?',
                [userId]
            );
            return true;
        } catch (error) {
            throw error;
        }
    },

    isTokenValid: async (userId) => {
        try {
            const [results] = await pool.execute(
                'SELECT token_valid FROM users WHERE id = ?',
                [userId]
            );
            return results[0]?.token_valid !== 0; //invalid 0
        } catch (error) {
            throw error;
        }
    },

    checkUsernameExists: async (username) => {
        try {
            const [results] = await pool.execute(
                'SELECT id FROM users WHERE username = ?',
                [username]
            );
            return results.length > 0;
        } catch (error) {
            throw error;
        }
    },

    checkEmailExists: async (email) => {
        try {
            const [results] = await pool.execute(
                'SELECT id FROM users WHERE email = ?',
                [email]
            );
            return results.length > 0;
        } catch (error) {
            throw error;
        }
    },

    create: async (userdata) => {
        try {

            const usernameExists = await module.exports.checkUsernameExists(userdata.username);
            if (usernameExists) {
                throw new Error('Username already exists');
            }
            
            // Check if email already exists
            const emailExists = await module.exports.checkEmailExists(userdata.email);
            if (emailExists) {
                throw new Error('Email already exists');
            }

            const [results] = await pool.execute(
            'INSERT INTO users (username, email, password, registration_date) values (?,?,?,?)',
            [
                userdata.username,
                userdata.email,
                userdata.password,
                userdata.registration_date
            ]
            );
            return results;
        } catch (error) {
            throw error;
        }
    },
    getUsers: async () => {
        try {
            const [results] = await pool.execute(
            'SELECT username, email, registration_date from users',
            );
            return results;
        } catch (error) {
            throw error;
        }
    },

    getUserByUserId: async (id) => {
        try {
            const [results] = await pool.execute(
            'SELECT username, email, registration_date from users where id = ?',
            [id]
            );
            return results[0];
        } catch (error) {
            throw error;
        }
    },

    updateUser: async (userdata) => {
        try {

            const [existingUsername] = await pool.execute(
                'SELECT id FROM users WHERE username = ? AND id != ?',
                [userdata.username, userdata.id]
            );
            if (existingUsername.length > 0) {
                throw new Error('Username already taken by another user');
            }
            
            // Check if the new email is already taken by another user
            const [existingEmail] = await pool.execute(
                'SELECT id FROM users WHERE email = ? AND id != ?',
                [userdata.email, userdata.id]
            );
            if (existingEmail.length > 0) {
                throw new Error('Email already taken by another user');
            }

            const [results] = await pool.execute(
            'UPDATE users set username=?, email=?, password=?, registration_date=? WHERE id= ?',
            [
                userdata.username,
                userdata.email,
                userdata.password,
                userdata.registration_date,
                userdata.id
            ]
            );
            return results;
        } catch (error) {
            throw error;
        }
    },

    getUserByUserEmail: async (email) => {
        try {
            const [results] = await pool.execute(
                'SELECT * FROM users WHERE email = ?',
                [email]
            );
            return results[0];
        } catch (error) {
            throw error;
        }
    },

    updateLoginInfo: async (userId) => {
        try {
            // First get current login count to determine if this is first login
            const [user] = await pool.execute(
                'SELECT login_count FROM users WHERE id = ?', 
                [userId]
            );
            
            const isFirstLogin = user[0].login_count === 0;
            
            // Update login count and set first login date if needed
            await pool.execute(
                `UPDATE users 
                 SET login_count = login_count + 1,
                     first_login_date = IF(login_count = 0, NOW(), first_login_date)
                 WHERE id = ?`,
                [userId]
            );
            
            return isFirstLogin;
        } catch (error) {
            throw error;
        }
    }   
};
